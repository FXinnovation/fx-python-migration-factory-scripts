#!/usr/bin/env python3

import argparse
import csv
import json
import logging
import os
import re

import mf
from mf.aws import AWSValidator
from mf.config_loaders import EndpointsLoader
from mf.migration_factory import MigrationFactoryRequester, CSVIntake
from mf.utils import EnvironmentVariableFetcher, MessageBag


class IntakeFormImporter:
    """ Import and prepare servers form wave in the Migration Factory """

    ALLOWED_SERVER_OS = ['windows', 'linux']
    ALLOWED_SERVER_TIER = ['app', 'db', 'wav']
    ALLOWED_TENANCY = ['Shared', 'Dedicated', 'Dedicated Host']

    _arguments = []
    _endpoints_loader = {}
    _migration_factory_requester = None
    _path_wave = ''
    _validation_error_bag = MessageBag('error')
    _csv_content = []

    def __init__(self):
        parser = argparse.ArgumentParser()
        parser.add_argument('-v', action='store_true', help='Enable info outputs')
        parser.add_argument('-vv', action='store_true', help='Enable debug outputs')
        parser.add_argument('--wave-name', required=True, help='Name of the wave to prepare')
        parser.add_argument(
            '--config-file-endpoints',
            default=EnvironmentVariableFetcher.fetch(
                env_var_names=mf.ENV_VAR_ENDPOINT_CONFIG_FILE,
                default=mf.DEFAULT_ENV_VAR_ENDPOINT_CONFIG_FILE
            ),
            help='Configuration file containing the Migration Factory endpoint URLs'
        )

        self._arguments = parser.parse_args()

        mf.setup_logging(logging, self._arguments.v, self._arguments.vv)

        self._path_wave = os.path.join(mf.PATH_HOME, self._arguments.wave_name)
        self._endpoints_loader = EndpointsLoader(endpoint_config_file=self._arguments.config_file_endpoints)
        self._migration_factory_requester = MigrationFactoryRequester(
            self._endpoints_loader
        )

    def read_wave_csv(self):
        if not self._csv_content:
            with open(os.path.join(self._path_wave, mf.FILE_CSV_WAVE_TEMPLATE), newline='') as csvfile:
                reader = csv.DictReader(csvfile)
                for row in reader:
                    self._csv_content.append(row)
                logging.getLogger('root').debug("{}: CSV content\n{}".format(
                    self.__class__.__name__, self._csv_content
                ))

        return self._csv_content

    def get_csv_content(self):
        return self.read_wave_csv()

    def import_file(self):
        apps_to_create = []
        apps_with_wave_to_create = []

        print('### Validating input CSV…', end=' ')

        self._validate_server_data(self.get_csv_content())

        for server in self.get_csv_content():
            existing_app = self._migration_factory_requester.get_user_app_by_name(server[CSVIntake.APP_NAME])

            if existing_app:
                logging.getLogger('root').info('{}: “{}” app already exists. Just need to be updated.'.format(
                    self.__class__.__name__, server[CSVIntake.APP_NAME]
                ))

                existing_wave = self._migration_factory_requester.get(
                    self._migration_factory_requester.URI_USER_WAVE.format(existing_app[CSVIntake.MF_WAVE_ID])
                )

                self._validate_app_with_existing(existing_app, existing_wave, server)
            else:
                apps_to_create = server

                existing_wave = self._migration_factory_requester.get_user_wave_by_name(server[CSVIntake.WAVE_NAME])

                if not existing_wave:
                    apps_with_wave_to_create = server

        self._validation_error_bag.unload(logging.getLogger('root'))

        print('✔ Done')

        print('### Create waves…')
        for app_with_wave_to_create in apps_with_wave_to_create:
            print('## New wave {}…'.format(app_with_wave_to_create[CSVIntake.WAVE_NAME]))

            data = {
                CSVIntake.MF_WAVE_NAME: app_with_wave_to_create[CSVIntake.WAVE_NAME],
                CSVIntake.MF_WAVE_DESCRIPTION: 'Wave for {}'.format(app_with_wave_to_create[CSVIntake.WAVE_NAME])
            }

            self._migration_factory_requester.post(
                uri=self._migration_factory_requester.URI_USER_WAVE_LIST,
                data=json.dumps(data)
            )

        if len(apps_with_wave_to_create) != 0:
            print('✔ Done')
        else:
            print('✔ Already Done')

        print('### Create apps…')
        for app_to_create in apps_to_create:
            existing_wave = self._migration_factory_requester.get_user_wave_by_name(app_to_create[CSVIntake.WAVE_NAME])
            print('## New app {}…'.format(app_to_create[CSVIntake.APP_NAME]))

            data = {
                CSVIntake.MF_WAVE_ID: existing_wave[CSVIntake.MF_WAVE_ID],
                CSVIntake.MF_APP_NAME: app_to_create[CSVIntake.APP_NAME],
                CSVIntake.MF_CLOUDENDURE_PROJECT_NAME: app_to_create[CSVIntake.CLOUDENDURE_PROJECT_NAME],
                CSVIntake.MF_AWS_ACCOUNT_ID: app_to_create[CSVIntake.AWS_ACCOUNT_ID],
            }

            self._migration_factory_requester.post(
                uri=self._migration_factory_requester.URI_USER_APP_LIST,
                data=json.dumps(data)
            )

        if len(apps_to_create) != 0:
            print('✔ Done')
        else:
            print('✔ Already Done')

        print('### Setting server data…')
        for server in self.get_csv_content():
            existing_server = self._migration_factory_requester.get_user_server_by_name(
                server[CSVIntake.SERVER_NAME]
            )
            existing_app = self._migration_factory_requester.get_user_app_by_name(
                server[CSVIntake.APP_NAME]
            )

            data = {
                CSVIntake.MF_APP_ID: existing_app[CSVIntake.MF_APP_ID],
                CSVIntake.MF_SERVER_NAME: server[CSVIntake.SERVER_NAME],
                CSVIntake.MF_SERVER_OS: server[CSVIntake.SERVER_OS],
                CSVIntake.MF_SERVER_OS_VERSION: server[CSVIntake.SERVER_OS_VERSION],
                CSVIntake.MF_SERVER_FQDN: server[CSVIntake.SERVER_FQDN],
                CSVIntake.MF_SERVER_TIER: server[CSVIntake.SERVER_TIER],
                CSVIntake.MF_SERVER_ENVIRONMENT: server[CSVIntake.SERVER_ENVIRONMENT],
                CSVIntake.MF_SUBNET_ID: server[CSVIntake.SUBNET_ID],
                CSVIntake.MF_SUBNET_ID_TEST: app_to_create[CSVIntake.SUBNET_ID_TEST],
                CSVIntake.MF_SECURITY_GROUP_ID: app_to_create[CSVIntake.SECURITY_GROUP_ID],
                CSVIntake.MF_SECURITY_GROUP_ID_TEST: app_to_create[CSVIntake.SECURITY_GROUP_ID_TEST],
                CSVIntake.MF_INSTANCE_TYPE: app_to_create[CSVIntake.INSTANCE_TYPE],
                CSVIntake.MF_TENANCY: app_to_create[CSVIntake.TENANCY],
                CSVIntake.MF_IAM_ROLE: app_to_create[CSVIntake.IAM_ROLE],
            }

            if existing_server:
                print('## Update server {}…'.format(server[CSVIntake.SERVER_NAME]))
                self._migration_factory_requester.put(
                    uri=self._migration_factory_requester.URI_USER_SERVER.format(
                        existing_server[CSVIntake.MF_SERVER_ID]
                    ),
                    data=json.dumps(data)
                )
            else:
                print('## New server {}…'.format(server[CSVIntake.SERVER_NAME]))
                self._migration_factory_requester.post(
                    uri=self._migration_factory_requester.URI_USER_APP_LIST,
                    data=json.dumps(data)
                )

            print('✔ Done')

    def _validate_app_with_existing(self, existing_app, existing_wave, server):
        if existing_app[CSVIntake.MF_CLOUDENDURE_PROJECT_NAME] != server[CSVIntake.CLOUDENDURE_PROJECT_NAME]:
            self._validation_error_bag.add(
                '{}: Given “{}” as CloudEndure project name does not match existing “{}”.'.format(
                    self.__class__.__name__,
                    server[CSVIntake.CLOUDENDURE_PROJECT_NAME],
                    existing_app[CSVIntake.MF_CLOUDENDURE_PROJECT_NAME]
                )
            )

        if existing_app[CSVIntake.MF_AWS_ACCOUNT_ID] != server[CSVIntake.AWS_ACCOUNT_ID]:
            self._validation_error_bag.add(
                '{}: Given “{}” as AWS accountID does not match existing “{}”.'.format(
                    self.__class__.__name__,
                    server[CSVIntake.AWS_ACCOUNT_ID],
                    existing_app[CSVIntake.MF_AWS_ACCOUNT_ID]
                )
            )

        if existing_wave[CSVIntake.MF_WAVE_NAME] != server[CSVIntake.WAVE_NAME]:
            self._validation_error_bag.add(
                '{}: Given “{}” as Wave name does not match existing “{}”.'.format(
                    self.__class__.__name__, server[CSVIntake.WAVE_NAME], existing_app[CSVIntake.MF_WAVE_NAME]
                )
            )

    def _validate_server_data(self, servers):
        self._check_dict_value_duplication(servers, CSVIntake.SERVER_NAME)
        self._check_dict_value_duplication(servers, CSVIntake.SERVER_FQDN)
        self._check_dict_value_consistency(servers, CSVIntake.WAVE_NAME)
        self._check_dict_value_consistency(servers, CSVIntake.CLOUDENDURE_PROJECT_NAME)
        self._check_dict_value_consistency(servers, CSVIntake.AWS_ACCOUNT_ID)

        for server_data in servers:
            self._validate_with_regexp(
                server_data[CSVIntake.AWS_ACCOUNT_ID], AWSValidator.REGEXP_ACCOUNT_ID, 'an account ID name'
            )
            self._validate_with_regexp(
                server_data[CSVIntake.WAVE_NAME], AWSValidator.REGEXP_CLOUDENDURE_PROJECT_NAME, 'a wave name'
            )
            self._validate_with_regexp(
                server_data[CSVIntake.CLOUDENDURE_PROJECT_NAME], AWSValidator.REGEXP_CLOUDENDURE_PROJECT_NAME,
                'a project name'
            )
            self._validate_with_regexp(
                server_data[CSVIntake.INSTANCE_TYPE], AWSValidator.REGEXP_INSTANCE_TYPE, 'an instance type'
            )

            self._validate_with_regexp(
                server_data[CSVIntake.SUBNET_ID], AWSValidator.REGEXP_SUBNET_ID, 'an AWS subnet ID'
            )
            self._validate_with_regexp(
                server_data[CSVIntake.SUBNET_ID_TEST], AWSValidator.REGEXP_SUBNET_ID, 'an AWS subnet ID'
            )

            self._validate_with_enum(server_data[CSVIntake.SERVER_OS], self.ALLOWED_SERVER_OS, 'a server OS')
            self._validate_with_enum(server_data[CSVIntake.SERVER_TIER], self.ALLOWED_SERVER_TIER, 'a server tier')
            self._validate_with_enum(server_data[CSVIntake.TENANCY], self.ALLOWED_TENANCY, 'a tenancy')

            for security_group in server_data[CSVIntake.SECURITY_GROUP_ID].split(';'):
                self._validate_with_regexp(security_group, AWSValidator.REGEXP_SECURITY_GROUP_ID, 'a security group ID')

            for security_group in server_data[CSVIntake.SECURITY_GROUP_ID_TEST].split(';'):
                self._validate_with_regexp(
                    security_group, AWSValidator.REGEXP_SECURITY_GROUP_ID, 'a security group ID (for test)'
                )

    def _check_dict_value_consistency(self, dict_to_check, key):
        if len(list(dict.fromkeys(map(lambda x: x[key].strip(), dict_to_check)))) != 1:
            self._validation_error_bag.add('{}: “{}” key is not consistent among all servers.'.format(
                self.__class__.__name__, key
            ))

    def _check_dict_value_duplication(self, dict_to_check, key):
        if list(map(lambda x: x[key].strip(), dict_to_check)).count(key) > 1:
            self._validation_error_bag.add('{}: “{}” key is duplicated among all servers.'.format(
                self.__class__.__name__, key
            ))

    def _validate_with_regexp(self, value, regexp, description):
        self._debug_validate(value)
        if not re.match(regexp, value):
            self._validation_error_bag.add('{}: Given “{}” as {} is invalid (failed regex: “{}”).'.format(
                self.__class__.__name__, value, description, regexp
            ))

    def _validate_with_enum(self, value, enum, description):
        self._debug_validate(value)
        if value not in enum and value.lower() not in enum:
            self._validation_error_bag.add('{}: Given “{}” as {} is invalid (allowed values: {}).'.format(
                self.__class__.__name__, value, description, str(enum)
            ))

    def _debug_validate(self, value):
        logging.getLogger('root').debug('{}: Validating user input: “{}”)'.format(
            self.__class__.__name__, value
        ))


if __name__ == '__main__':
    intake_form_importer = IntakeFormImporter()
    intake_form_importer.import_file()
