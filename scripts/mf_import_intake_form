#!/usr/bin/env python3

from __future__ import print_function

import argparse
import csv
import json
import logging
import os
import re

import mf
from mf.aws import AWSValidator
from mf.config_loaders import EndpointsLoader
from mf.migration_factory import MigrationFactoryRequester, CSVIntake
from mf.utils import EnvironmentVariableFetcher, MessageBag


class IntakeFormImporter:
    """ Import and prepare servers form wave in the Migration Factctory """

    ALLOWED_SERVER_OS = ['windows', 'linux']
    ALLOWED_SERVER_TIER = ['app', 'db', 'wav']
    ALLOWED_TENANCY = ['Shared', 'Dedicated', 'Dedicated Host']

    _arguments = []
    _endpoints_loader = {}
    _migration_factory_requester = None
    _path_wave = ''
    _validation_error_bag = MessageBag('error')
    _csv_content = []

    def __init__(self):
        parser = argparse.ArgumentParser()
        parser.add_argument('-v', action='store_true', help='Enable info outputs')
        parser.add_argument('-vv', action='store_true', help='Enable debug outputs')
        parser.add_argument('--wave-name', required=True, help='Name of the wave to prepare')
        parser.add_argument(
            '--config-file-endpoints',
            default=EnvironmentVariableFetcher.fetch(
                env_var_names=mf.ENV_VAR_ENDPOINT_CONFIG_FILE,
                default=mf.DEFAULT_ENV_VAR_ENDPOINT_CONFIG_FILE
            ),
            help='Configuration file containing the Migration Factory endpoint URLs'
        )

        self._arguments = parser.parse_args()

        mf.setup_logging(logging, self._arguments.v, self._arguments.vv)

        self._path_wave = os.path.join(mf.PATH_HOME, self._arguments.wave_name)
        self._endpoints_loader = EndpointsLoader(endpoint_config_file=self._arguments.config_file_endpoints)
        self._migration_factory_requester = MigrationFactoryRequester(
            self._endpoints_loader
        )

    def read_wave_csv(self):
        if not self._csv_content:
            with open(os.path.join(self._path_wave, mf.FILE_CSV_WAVE_TEMPLATE), newline='') as csvfile:
                reader = csv.DictReader(csvfile)
                for row in reader:
                    self._csv_content.append(row)
                logging.getLogger('root').debug("{}: CSV content\n{}".format(
                    self.__class__.__name__, self._csv_content
                ))

        return self._csv_content

    def get_csv_content(self):
        return self.read_wave_csv()

    def import_file(self):
        wave_ids = []
        servers_data = []

        self._validate_server_data(self.get_csv_content())

        for server in self.get_csv_content():
            existing_app = self._migration_factory_requester.get_user_app_by_name(server[CSVIntake.APP_NAME])

            if existing_app:
                existing_wave = self._migration_factory_requester.get(
                    self._migration_factory_requester.URI_USER_WAVE.format(existing_app[CSVIntake.MF_WAVE_NAME])
                )

                logging.getLogger('root').debug('{}: app already exists. Need to be updated.'.format(
                    self.__class__.__name__, server[CSVIntake.APP_NAME]
                ))

                self._validate_app_with_existing(existing_app, existing_wave, server)

        self._validation_error_bag.unload(logging.getLogger('root'))

        quit()

        for server_raw in self.get_csv_content():
            wave_ids.append(str(server_raw['wave_id']).strip())

            server_data = {
                'app_name': server_raw['app_name'].strip(),
                'wave_name': server_raw['wave_id'].strip(),
                'cloudendure_projectname': server_raw['cloudendure_projectname'].strip(),
                'aws_accountid': server_raw['aws_accountid'].strip()
            }

            servers_data.append(server_data)

        # print(list(map(lambda x: x['app_name'].strip().lower(), servers_raw)))
        # print(list(set(map(lambda x: x['app_name'].strip().lower(), servers_raw)) - set(
        #     map(lambda x: x['app_name'].strip().lower(), all_apps))))

        exit(0)

        self._migration_factory_requester.post(
            url=self._migration_factory_requester.KEY_USER_API_URL,
            uri=self._migration_factory_requester.URI_USER_WAVE_LIST,
            data=json.dumps(self._arguments.wave_name)
        )

        self._migration_factory_requester.post(
            url=self._migration_factory_requester.KEY_USER_API_URL,
            uri=self._migration_factory_requester.URI_USER_APP_LIST,
            data=json.dumps(map(lambda x: x['app_name'].strip().lower(), self.get_csv_content()))
        )

    def _validate_app_with_existing(self, existing_app, existing_wave, server):
        if existing_app[CSVIntake.MF_CLOUDENDURE_PROJECT_NAME] != server[CSVIntake.CLOUDENDURE_PROJECT_NAME]:
            self._validation_error_bag.add(
                '{}: Given “{}” as CloudEndure project name does not match existing “{}”.'.format(
                    self.__class__.__name__,
                    server[CSVIntake.CLOUDENDURE_PROJECT_NAME],
                    existing_app[CSVIntake.MF_CLOUDENDURE_PROJECT_NAME]
                )
            )

        if existing_app[CSVIntake.MF_AWS_ACCOUNT_ID] != server[CSVIntake.AWS_ACCOUNT_ID]:
            self._validation_error_bag.add(
                '{}: Given “{}” as AWS accountID does not match existing “{}”.'.format(
                    self.__class__.__name__,
                    server[CSVIntake.AWS_ACCOUNT_ID],
                    existing_app[CSVIntake.MF_AWS_ACCOUNT_ID]
                )
            )

        if existing_wave[CSVIntake.MF_WAVE_NAME] != server[CSVIntake.WAVE_NAME]:
            self._validation_error_bag.add(
                '{}: Given “{}” as Wave name does not match existing “{}”.'.format(
                    self.__class__.__name__, server[CSVIntake.WAVE_NAME], existing_app[CSVIntake.MF_WAVE_NAME]
                )
            )

    def _validate_server_data(self, servers):
        self._check_dict_value_duplication(servers, CSVIntake.SERVER_NAME)
        self._check_dict_value_duplication(servers,  CSVIntake.SERVER_FQDN)
        self._check_dict_value_consistency(servers, CSVIntake.WAVE_NAME)
        self._check_dict_value_consistency(servers,  CSVIntake.CLOUDENDURE_PROJECT_NAME)
        self._check_dict_value_consistency(servers,  CSVIntake.AWS_ACCOUNT_ID)

        for server_data in servers:
            self._validate_with_regexp(
                server_data[CSVIntake.AWS_ACCOUNT_ID], AWSValidator.REGEXP_ACCOUNT_ID, 'an account ID name'
            )
            self._validate_with_regexp(
                server_data[CSVIntake.WAVE_NAME], AWSValidator.REGEXP_CLOUDENDURE_PROJECT_NAME, 'a wave name'
            )
            self._validate_with_regexp(
                server_data[CSVIntake.CLOUDENDURE_PROJECT_NAME], AWSValidator.REGEXP_CLOUDENDURE_PROJECT_NAME, 'a project name'
            )
            self._validate_with_regexp(
                server_data[CSVIntake.INSTANCE_TYPE], AWSValidator.REGEXP_INSTANCE_TYPE, 'an instance type'
            )

            self._validate_with_regexp(
                server_data[CSVIntake.SUBNET_ID], AWSValidator.REGEXP_SUBNET_ID, 'an AWS subnet ID'
            )
            self._validate_with_regexp(
                server_data[CSVIntake.SUBNET_ID_TEST], AWSValidator.REGEXP_SUBNET_ID, 'an AWS subnet ID'
            )

            self._validate_with_enum(server_data[CSVIntake.SERVER_OS], self.ALLOWED_SERVER_OS, 'a server OS')
            self._validate_with_enum(server_data[CSVIntake.SERVER_TIER], self.ALLOWED_SERVER_TIER, 'a server tier')
            self._validate_with_enum(server_data[CSVIntake.TENANCY], self.ALLOWED_TENANCY, 'a tenancy')

            for security_group in server_data[CSVIntake.SECURITY_GROUP_ID].split(';'):
                self._validate_with_regexp(security_group, AWSValidator.REGEXP_SECURITY_GROUP_ID, 'a security group ID')

            for security_group in server_data[CSVIntake.SECURITY_GROUP_ID_TEST].split(';'):
                self._validate_with_regexp(
                    security_group, AWSValidator.REGEXP_SECURITY_GROUP_ID, 'a security group ID (for test)'
                )

    def _check_dict_value_consistency(self, dict_to_check, key):
        if len(list(dict.fromkeys(map(lambda x: x[key].strip(), dict_to_check)))) != 1:
            self._validation_error_bag.add('{}: “{}” key is not consistent among all servers.'.format(
                self.__class__.__name__, key
            ))

    def _check_dict_value_duplication(self, dict_to_check, key):
        if list(map(lambda x: x[key].strip(), dict_to_check)).count(key) > 1:
            self._validation_error_bag.add('{}: “{}” key is duplicated among all servers.'.format(
                self.__class__.__name__, key
            ))

    def _validate_with_regexp(self, value, regexp, description):
        self._debug_validate(value)
        if not re.match(regexp, value):
            self._validation_error_bag.add('{}: Given “{}” as {} is invalid (failed regex: “{}”).'.format(
                self.__class__.__name__, value, description, regexp
            ))

    def _validate_with_enum(self, value, enum, description):
        self._debug_validate(value)
        if value.lower() not in enum:
            self._validation_error_bag.add('{}: Given “{}” as {} is invalid (allowed values: {}).'.format(
                self.__class__.__name__, value, description, str(enum)
            ))

    def _debug_validate(self, value):
        logging.getLogger('root').debug('{}: Validating user input: “{}”)'.format(
            self.__class__.__name__, value
        ))


#
# def convert_string_to_list(row_str):
#     row_list = []
#     row_list = row_str.split(';')
#     return row_list
#
# def uploading_data(data, token):
#     wave_list_csv = []
#     app_list_csv = []
#     wave_ids = []
#     app_list = []
#     server_list = []
#
#     for row in data:
#         if row['wave_id'].strip() not in wave_list_csv:
#             wave_list_csv.append(str(row['wave_id']).strip())
#
#         app_item = {}
#         app_item['app_name'] = row['app_name'].strip()
#         app_item['wave_name'] = "Wave " + row['wave_id'].strip()
#         app_item['cloudendure_projectname'] = row['cloudendure_projectname'].strip()
#         app_item['aws_accountid'] = row['aws_accountid'].strip()
#         app_list_csv.append(app_item)
#
#     # Get Unique new Wave Id, add to the list if Wave Id doesn't exist in the factory
#     for wave_id in wave_list_csv:
#         match = False
#         for wave in waves:
#             wave_name = "Wave " + wave_id
#             if str(wave_name) == str(wave['wave_name']):
#                 match = True
#         if (match == False):
#             wave_ids.append(wave_id)
#     if len(wave_ids) is not 0:
#         print("New Waves: ")
#         print("")
#         for wave in wave_ids:
#             print("Wave " + wave)
#         print("")
#         # Creating new Waves in the migration factory
#         for wave in wave_ids:
#             wave_name = {}
#             wave_name['wave_name'] = "Wave " + wave
#
#             for new_wave in new_waves:
#                 if wave_name['wave_name'] == new_wave['wave_name']:
#                     new_wave_id = new_wave['wave_id']
#                     break
#             if r.status_code == 200:
#                 print("Wave " + wave + " (ID: " + new_wave_id + ") created in the migration factory")
#             else:
#                 print("Wave " + wave + " failed : " + r.text + ".......")
#         print("")
#         print("----------------------------------------")
#         print("")
#
#     # Get Unique new App Name, add to the resource list if App Name doesn't exist in the factory
#     for app_csv in app_list_csv:
#         new_waves = json.loads(requests.get(UserHOST + waveendpoint, headers=auth).text)
#         for wave in new_waves:
#             if app_csv['wave_name'] == str(wave['wave_name']):
#                 app_csv['wave_id'] = wave['wave_id']
#                 del app_csv['wave_name']
#                 break
#         match = False
#         for app in apps:
#             if app_csv['app_name'].lower().strip() == app['app_name'].lower().strip():
#                 match = True
#                 if app_csv['wave_id'] != app['wave_id']:
#                     print("Error: Wave_id for app " + app_csv['app_name'] + " doesn't match the Wave_id for the same app in the factory")
#                     sys.exit(2)
#                 if app_csv['cloudendure_projectname'] != app['cloudendure_projectname']:
#                     print("Error: cloudendure_projectname for app " + app_csv['app_name'] + " doesn't match the cloudendure_projectname for the same app in the factory")
#                     sys.exit(3)
#                 if app_csv['aws_accountid'] != app['aws_accountid']:
#                     print("Error: aws_accountid for app " + app_csv['app_name'] + " doesn't match the aws_accountid for the same app in the factory")
#                     sys.exit(4)
#         if (match == False):
#             app_list.append(app_csv)
#     if len(app_list) is not 0:
#         print("New Apps: ")
#         print("")
#         for app in app_list:
#             print(app["app_name"])
#         print("")
#         # Creating new Apps in the migration factory
#         for app in app_list:
#             r = requests.post(UserHOST + appendpoint, headers=auth, data=json.dumps(app))
#             if r.status_code == 200:
#                 print("App " + app['app_name'] + " created in the migration factory")
#             else:
#                 print("App " + app['app_name'] + " failed : " + r.text + ".......")
#         print("")
#         print("----------------------------------------")
#         print("")
#     # Get Unique server names, add to the resource list if Server Name doesn't exist in the factory
#     newapps = json.loads(requests.get(UserHOST + appendpoint, headers=auth).text)
#     for row in data:
#         for app in newapps:
#             if row['app_name'].lower().strip() == app['app_name'].lower().strip():
#                row['app_id'] = app['app_id']
#         tags = []
#         tag = {}
#         server_item = {}
#         server_item['server_name'] = row['server_name'].strip()
#         tag['key'] = 'Name'
#         tag['value'] = row['server_name'].strip()
#         tags.append(tag)
#         server_item['tags'] = tags
#         server_item['app_id'] = row['app_id'].strip()
#         server_item['server_os'] = row['server_os'].strip()
#         server_item['server_os_version'] = row['server_os_version'].strip()
#         server_item['server_fqdn'] = row['server_fqdn'].strip()
#         server_item['server_tier'] = row['server_tier'].strip()
#         server_item['server_environment'] = row['server_environment'].strip()
#         server_item['subnet_IDs'] = convert_string_to_list(row['subnet_IDs'].strip())
#         server_item['securitygroup_IDs'] = convert_string_to_list(row['securitygroup_IDs'].strip())
#         server_item['subnet_IDs_test'] = convert_string_to_list(row['subnet_IDs_test'].strip())
#         server_item['securitygroup_IDs_test'] = convert_string_to_list(row['securitygroup_IDs_test'].strip())
#         server_item['instanceType'] = row['instanceType'].strip()
#         server_item['tenancy'] = row['tenancy'].strip()
#         server_item['iamRole'] = row['iamRole'].strip()
#         server_list.append(server_item)
#     if len(server_list) is not 0:
#         print("New Servers: ")
#         print("")
#         for server in server_list:
#             print(server['server_name'])
#         print("")
#         # Creating new Apps in the migration factory
#         for server in server_list:
#             r = requests.post(UserHOST + serverendpoint, headers=auth, data=json.dumps(server))
#             if r.status_code == 200:
#                 print("Server " + server['server_name'] + " created in the migration factory")
#             else:
#                 print("ERROR: " + server['server_name'] + " failed : " + r.text + ".......")
#
#
# print("****************************")
# print("Intake form data loaded for processing....")
# print("")
#
# print("*********************************************")
# print("*Creating resources in the migration factory*")
# print("*********************************************")
#
# r = uploading_data(data,token)


if __name__ == '__main__':
    intake_form_importer = IntakeFormImporter()
    intake_form_importer.import_file()
