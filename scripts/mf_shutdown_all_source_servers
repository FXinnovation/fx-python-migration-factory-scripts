#!/usr/bin/env python3

from __future__ import print_function
import sys
import argparse
import requests
import json
import subprocess
import getpass
import paramiko
import os

import mf
from mf.utils import EnvironmentVariableFetcher
from mf.config_loaders import EndpointsLoader, ConfigLoader
from mf.migration_factory import MigrationFactoryRequester, MfField, MigrationFactoryAuthenticator
from mf.cloud_endure import CloudEndureRequester
from mf.aws import AWSServiceAccessor

serverendpoint = '/prod/user/servers'
appendpoint = '/prod/user/apps'

class Shutdown:

    _path = None
    _domain_password = None
    _cloud_endure_requester = None
    _migration_factory_requester = None
    _config_loader = None
    _endpoints_loader = None

    def __init__(self):
        parser = argparse.ArgumentParser()
        parser.add_argument('-v', action='store_true', help='Enable info outputs')
        parser.add_argument('-vv', action='store_true', help='Enable debug outputs')
        parser.add_argument('--wave-name', required=True, help='Name of the wave to act on')
        parser.add_argument('--windows-username', default =
            EnvironmentVariableFetcher.fetch(
                env_var_names=mf.ENV_VAR_WINDOWS_USERNAME,
                default=''
            ),
            help= "The windows username"
        )
        parser.add_argument('--linux-username', default =
            EnvironmentVariableFetcher.fetch(
                env_var_names=mf.ENV_VAR_LINUX_USERNAME,
                default=''
            ),
            help= "The linux username"
        )
        parser.add_argument('--linux-private-key-file', default =
            EnvironmentVariableFetcher.fetch(
                env_var_names=mf.ENV_VAR_LINUX_PRIVATE_KEY_FILE,
                default=''
            ),
            help= "The linux private key file"
        )
        parser.add_argument(
            '--config-file-endpoints',
            default=EnvironmentVariableFetcher.fetch(
                env_var_names=mf.ENV_VAR_ENDPOINT_CONFIG_FILE,
                default=mf.DEFAULT_ENV_VAR_ENDPOINT_CONFIG_FILE
            ),
            help='Configuration file containing the Migration Factory endpoint URLs'
        )

        self._arguments = parser.parse_args()

        mf.setup_logging(logging, self._arguments.v, self._arguments.vv)

        self._endpoints_loader = EndpointsLoader(endpoint_config_file=self._arguments.config_file_endpoints)
        self._migration_factory_requester = MigrationFactoryRequester(
            self._endpoints_loader
        )
        self._cloud_endure_requester = CloudEndureRequester()

        self._aws_service_accessor = AWSServiceAccessor()

        if self._has_windows_user():
            self._domain_password = EnvironmentVariableFetcher.fetch(
                env_var_names=mf.ENV_VAR_WINDOWS_PASSWORD,
                env_var_description='Windows password',
                default='',
                sensitive=True
            )

        self._config_loader = ConfigLoader()

    def main(self):

        domain_user = self._arguments.windows_username
        print("#######################")
        print("#Login to Migration factory…")
        print("##Get servers list…")

        winServers = self._migration_factory_requester.get_user_servers_by_wave_and_os(filter_wave_name = self._arguments.wave_name, filter_os = 'windows')
        linuxServers = self._migration_factory_requester.get_user_servers_by_wave_and_os(filter_wave_name = self._arguments.wave_name, filter_os = 'linux')

        if len(winServers) > 0:
            print("###Shutting down Windows servers…")
            for s in winServers:
                command = "Invoke-Command -ComputerName " + s + " -ScriptBlock {Stop-Computer -Force}"
                if domain_user != "":
                command += " -Credential (New-Object System.Management.Automation.PSCredential('" + domain_user + "', (ConvertTo-SecureString '" + self._domain_password + "' -AsPlainText -Force))) -Authentication Negotiate"
                print("Shutting down server: " + s)
                p = subprocess.Popen(["pwsh", "-Command", command], stdout=sys.stdout)
                p.communicate()
        if len(linuxServers) > 0:
            print("")
            print("###Shutting down Linux servers…")
            print("")
            user_name = self._arguments.linux_username if self._arguments.linux_username.lower().strip() != '' else EnvironmentVariableFetcher.fetch(env_var_names=mf.ENV_VAR_LINUX_USERNAME, env_var_description='Linux username')
            has_key = self._arguments.linux_private_key_file.lower().strip() != ''
            if has_key:
                pass_key = self._arguments.linux_private_key_file
            else:
                pass_key = EnvironmentVariableFetcher.fetch(env_var_names=mf.ENV_VAR_LINUX_PASSWORD, env_var_description='Linux password', sensitive=True)
                print("")
            for s in linuxServers:
                output, error = execute_cmd(s, user_name, pass_key, "sudo shutdown now", has_key in 'y')
                if not error:
                    print("#####Shutdown successful on " + s)
                else:
                    print("!!!! Unable to shutdown server " + s + " due to " + error)
                print("")

    def open_ssh(host, username, key_pwd, using_key):
        ssh = None
        try:
            if using_key:
                private_key = paramiko.RSAKey.from_private_key_file(key_pwd)
                ssh = paramiko.SSHClient()
                ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                ssh.connect(hostname=host, username=username, pkey=private_key)
            else:
                ssh = paramiko.SSHClient()
                ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                ssh.connect(hostname=host, username=username, password=key_pwd)
        except IOError as io_error:
            error = "Unable to connect to host " + host + " with username " + \
                    username + " due to " + str(io_error)
            print(error)
        except paramiko.SSHException as ssh_exception:
            error = "Unable to connect to host " + host + " with username " + \
                    username + " due to " + str(ssh_exception)
            print(error)
        return ssh


    def execute_cmd(host, username, key, cmd, using_key):
        output = ''
        error = ''
        ssh = None
        try:
            ssh = open_ssh(host, username, key, using_key)
            if ssh is None:
                error = "Not able to get the SSH connection for the host " + host
                print(error)
            else:
                stdin, stdout, stderr = ssh.exec_command(cmd)
                for line in stdout.readlines():
                    output = output + line
                for line in stderr.readlines():
                    error = error + line
        except IOError as io_error:
            error = "Unable to execute the command " + cmd + " on " +host+ " due to " + \
                    str(io_error)
            print(error)
        except paramiko.SSHException as ssh_exception:
            error = "Unable to execute the command " + cmd + " on " +host+ " due to " + \
                    str(ssh_exception)
            print(error)
        except Exception as e:
            error = "Unable to execute the command " + cmd + " on " +host+ " due to " + str(e)
            print(error)
        finally:
            if ssh is not None:
                ssh.close()
        return output, error

    def ping_servers(server_list):
        for server in server_list:
            ping_result[server] = subprocess.Popen(['ping', '-n', '-w5', '-c3', server], stdout=subprocess.DEVNULL)

        while ping_result:
            for server, proc in ping_result.items():
                if proc.poll() is not None: # ping finished
                    del p[server]
                    if proc.returncode == 0:
                        print('%s remain active' % server)
                    elif proc.returncode == 1:
                        print('%s is shutdown' % server)
                    else:
                        print('%s error' % server)
                    break

if __name__ == '__main__':
    Shutdown_execution = Shutdown()
    Shutdown_execution.main
    sys.exit(main(sys.argv[1:]))
