#!/usr/bin/env python3

from __future__ import print_function

import argparse
import glob
import logging
import ntpath
import os
from threading import Thread

import mf
from mf.config_loaders import EndpointsLoader, ConfigLoader
from mf.migration_factory import MigrationFactoryRequester, MfField
from mf.notification import Notifier
from mf.ssh import SSHConnector
from mf.utils import EnvironmentVariableFetcher, PowershellRunner


class PostLaunchFileCopier:
    """ Copy post-launch files from to the source servers (Windows only) """

    WINDOWS_POST_LAUNCH_DESTINATION = 'c:\\Program Files (x86)\\CloudEndure\\post_launch'

    _arguments = []
    _endpoints_loader = {}
    _migration_factory_requester = None
    _path_wave_post_launch = None
    _windows_user = None
    _windows_password = None
    _linux_user = None
    _linux_password = None
    _notifier = None
    _config_loader = None
    _ssh_connector = None
    _ssh_client = None

    _create_destination_tasks = []
    _copy_files_tasks = []
    _cleanup_tasks = []

    def __init__(self):
        parser = argparse.ArgumentParser()
        parser.add_argument('-v', action='store_true', help='Enable info outputs')
        parser.add_argument('-vv', action='store_true', help='Enable debug outputs')
        parser.add_argument('--wave-name', required=True, help='Name of the wave to act on')
        parser.add_argument('--skip-notify', action='store_true', help='Do not notify at the of the copy')
        parser.add_argument(
            '--config-file-endpoints',
            default=EnvironmentVariableFetcher.fetch(
                env_var_names=mf.ENV_VAR_ENDPOINT_CONFIG_FILE,
                default=mf.DEFAULT_ENV_VAR_ENDPOINT_CONFIG_FILE
            ),
            help='Configuration file containing the Migration Factory endpoint URLs'
        )
        parser.add_argument(
            '--generic-post-launch-directory',
            default=mf.PATH_DEFAULT_POST_LAUNCH,
            help="Generic post-launch files to copy (.exe, .bat or .sh)."
                 " Defaults to env var {}."
                 " Specific post-launch files will ALWAYS be fetched in wave directory dynamically.".format(
                mf.PATH_DEFAULT_POST_LAUNCH
            )
        )
        parser.add_argument(
            '--windows-username',
            default=EnvironmentVariableFetcher.fetch(
                env_var_names=mf.ENV_VAR_WINDOWS_USERNAME,
                default_is_none=True
            ),
            help="The Windows username for the remote session to Windows machines. "
                 "Defaults to env {}.".format(mf.ENV_VAR_WINDOWS_USERNAME[0])
        )
        parser.add_argument(
            '--windows-password',
            default=EnvironmentVariableFetcher.fetch(
                env_var_names=mf.ENV_VAR_WINDOWS_PASSWORD,
                default_is_none=True,
                sensitive=True
            ),
            help="The Windows password associated with the Windows username. "
                 "Defaults to env {}."
                 "Using this parameter with a cleartext password is NOT recommended.".format(
                mf.ENV_VAR_WINDOWS_PASSWORD[0]
            )
        )
        parser.add_argument(
            '--linux-username',
            default=EnvironmentVariableFetcher.fetch(
                env_var_names=mf.ENV_VAR_LINUX_USERNAME,
                default_is_none=True
            ),
            help="The Linux username for Linux Machines. "
                 "Defaults to env var {}. ".format(mf.ENV_VAR_LINUX_USERNAME[0])
        )
        parser.add_argument(
            '--linux-password',
            default=EnvironmentVariableFetcher.fetch(
                env_var_names=mf.ENV_VAR_LINUX_PASSWORD,
                default_is_none=True,
                sensitive=True
            ),
            help="The Linux password associated with the Linux username."
                 "Defaults to env var {}."
                 "The password is ignored if SSH private key file is set."
                 "Using this parameter with a cleartext password is NOT recommended.".format(
                mf.ENV_VAR_LINUX_PASSWORD[0]
            )
        )
        parser.add_argument(
            '--linux-ssh-private-key-file',
            default=EnvironmentVariableFetcher.fetch(
                env_var_names=mf.ENV_VAR_LINUX_PRIVATE_KEY_FILE,
                default_is_none=True
            ),
            help="Complete filename to the linux private key file for Linux machines."
        )
        parser.add_argument(
            '--linux-ssh-private-key-passphrase',
            default=EnvironmentVariableFetcher.fetch(
                env_var_names=mf.ENV_VAR_LINUX_PRIVATE_KEY_PASSPHRASE,
                default_is_none=True
            ),
            help="The passphrase for the SSH private key file for the linux machines."
        )

        self._arguments = parser.parse_args()

        mf.setup_logging(logging, self._arguments.v, self._arguments.vv)

        self._path_wave_post_launch = os.path.join(mf.PATH_HOME, self._arguments.wave_name, mf.DIRECTORY_POST_LAUNCH)
        self._endpoints_loader = EndpointsLoader(endpoint_config_file=self._arguments.config_file_endpoints)
        self._migration_factory_requester = MigrationFactoryRequester(
            self._endpoints_loader
        )
        self._config_loader = ConfigLoader()
        self._notifier = Notifier(self._config_loader.get_notifications_config())
        self._windows_user = self._arguments.windows_username
        self._windows_password = self._arguments.windows_password
        self._linux_user = self._arguments.linux_username
        self._linux_password = self._arguments.linux_password

    def copy(self):
        if not os.path.exists(self._arguments.generic_post_launch_directory):
            logging.error('{}: “{}” directory (for generic post launch files) does not exists.'.format(
                self.__class__.__name__, self._arguments.generic_post_launch_directory
            ))

        print('### Fetching servers list…', end='', flush=True)
        servers = self._migration_factory_requester.get_user_servers_by_wave(
            self._arguments.wave_name
        )
        logging.getLogger('root').debug(
            self.__class__.__name__ + ":Found servers: \n “{}”".format(servers)
        )
        print(' ✔ Done')

        if servers is []:
            print('### No servers found in the {} wave…').format(self._arguments.wave_name)
            quit(0)

        print('### Copying post-launch files to post-launch folder in source servers…')

        for server in servers:
            server_fqdn = server[MfField.SERVER_FQDN].strip()

            if "windows" in server[MfField.SERVER_OS].lower():
                self._start_copy_for_windows(server_fqdn)
            elif "linux" in server[MfField.SERVER_OS].lower():
                self._start_copy_for_linux(server_fqdn)

        for task in self._create_destination_tasks:
            print("# Creating post-launch directory on server: “{}”…".format(task.getName()))
            task.start()

        for task in self._create_destination_tasks:
            task.join()
            print('# ✔ Done: {} '.format(task.getName()))

        for task in self._copy_files_tasks:
            print("# Copying files: {}…".format(task.getName()))
            task.start()

        for task in self._copy_files_tasks:
            task.join()
            print('# ✔ Done: {}'.format(task.getName()))

        for task in self._cleanup_tasks:
            print("# Cleanup task: {}…".format(task.getName()))
            task.start()

        for task in self._cleanup_tasks:
            task.join()
            print('# ✔ Done: {}'.format(task.getName()))

        if self._ssh_client is not None:
            self._ssh_client.close()

        print('### ✔ Done')

        if self._arguments.skip_notify:
            return

        print('### Notifying…', end='', flush=True)

        # Currently not possible to notify conditionally of the Threads executions before.
        # It would need to use another Threading implementation that returns results (threading.Thread don't)
        self._notifier.notify(
            Notifier.POST_LAUNCH_SCRIPTS_UPDATED,
            Notifier.POST_LAUNCH_SCRIPTS_UPDATED_MESSAGE.format(self._arguments.wave_name)
        )

        print(' ✔ Done')

    def _start_copy_for_linux(self, server_fqdn: str):
        if not self._has_linux_user():
            self._linux_user = EnvironmentVariableFetcher.fetch(
                env_var_names=mf.ENV_VAR_LINUX_USERNAME,
                env_var_description='Linux username for SSH',
            )

        if self._has_linux_user() and not self._has_linux_password() and not self._has_linux_private_key():
            self._linux_password = EnvironmentVariableFetcher.fetch(
                env_var_names=mf.ENV_VAR_LINUX_PASSWORD,
                env_var_description='Linux password for SSH',
                sensitive=True
            )

        self._get_ssh_connector().set_hostname(server_fqdn)
        self._ssh_client = self._get_ssh_connector().connect(
            key_file_path=self._arguments.linux_ssh_private_key_file,
            key_passphrase=self._arguments.linux_ssh_private_key_passphrase,
            password=self._linux_password,
        )

        self._create_destination_tasks.append(Thread(
            target=self._ssh_client.execute,
            args=[self._get_linux_create_path_command()],
            name=server_fqdn
        ))

        for file_path in self._find_all_linux_scripts(self._path_wave_post_launch):
            for filename in glob.glob(file_path):
                self._copy_files_tasks.append(Thread(
                    target=self._ssh_client.sftp_put,
                    args=[filename, '/boot/post_launch/' + ntpath.basename(filename)],
                    name=server_fqdn
                ))

        self._cleanup_tasks.append(Thread(
            target=self._ssh_client.execute,
            args=["sudo chmod -R 0755 /boot/post_launch"],
            name='fixing permissions on post_launch on {}'.format(server_fqdn)
        ))

    def _start_copy_for_windows(self, server_fqdn: str):
        if not self._has_windows_user():
            self._windows_user = EnvironmentVariableFetcher.fetch(
                env_var_names=mf.ENV_VAR_WINDOWS_USERNAME,
                env_var_description='Windows username for remote session',
            )

        if self._has_windows_user() and not self._has_windows_password():
            self._windows_password = EnvironmentVariableFetcher.fetch(
                env_var_names=mf.ENV_VAR_WINDOWS_PASSWORD,
                env_var_description='Windows password for remote session',
                sensitive=True
            )

        self._create_destination_tasks.append(Thread(
            target=self._do_run_powershell,
            args=[self._get_windows_create_path_command(server_fqdn)],
            name=server_fqdn
        ))

        all_scripts_pathes = self._find_all_windows_scripts(self._arguments.generic_post_launch_directory)
        all_scripts_pathes.extend(self._find_all_windows_scripts(self._path_wave_post_launch))

        for script_path in all_scripts_pathes:
            self._copy_files_tasks.append(Thread(
                target=self._do_run_powershell,
                args=[self._get_windows_copy_command(script_path, server_fqdn)],
                name='from “{}” to “{}”'.format(script_path, server_fqdn)
            ))

    @classmethod
    def _find_all_windows_scripts(cls, basepath: str) -> list:
        return [
            f'{basepath}/*.bat',
            f'{basepath}/*.exe',
            f'{basepath}/*.cmd',
            f'{basepath}/*.ps1',
        ]

    @classmethod
    def _find_all_linux_scripts(cls, basepath: str) -> list:
        return [
            f'{basepath}/*.sh',
        ]

    def _get_windows_create_path_command(self, server_fqdn: str) -> str:
        create_path_command = f'Invoke-Command -ComputerName {server_fqdn} ' \
                              f'-ScriptBlock {{if (!(Test-path "{self.WINDOWS_POST_LAUNCH_DESTINATION}")) {{' \
                              f'New-Item -Path "{self.WINDOWS_POST_LAUNCH_DESTINATION}" -ItemType directory}}' \
                              f'}}'

        if self._has_windows_user():
            create_path_command = PowershellRunner.authenticate_command(
                create_path_command,
                self._windows_user,
                self._windows_password
            )

        return create_path_command

    def _get_linux_create_path_command(self) -> str:
        return "sudo mkdir -p /boot/post_launch && sudo chmod 0777 /boot/post_launch"

    def _get_windows_copy_command(self, filepath: str, server_fqdn: str, ) -> str:
        copy_command = 'Copy-Item "{}" "{}" -ToSession (New-PSSession -ComputerName "{}" %s) | Out-Null'.format(
            filepath,
            self.WINDOWS_POST_LAUNCH_DESTINATION,
            server_fqdn,
            '{}',
        )

        if self._has_windows_user():
            copy_command = PowershellRunner.insert_authenthication_arguments(
                copy_command,
                self._windows_user,
                self._windows_password
            )
        else:
            copy_command = copy_command % ''

        return copy_command

    def _do_run_powershell(self, command: str):
        logging.getLogger('root').info(
            self.__class__.__name__ + ':Running “{}”'.format(command)
        )

        PowershellRunner.run(command)

    def _get_ssh_connector(self):
        if self._ssh_connector is None:
            self._ssh_connector = SSHConnector(user=self._linux_user, hostname='', port=22)

        return self._ssh_connector

    def _has_windows_user(self):
        return self._windows_user is not None

    def _has_windows_password(self):
        return self._windows_password is not None

    def _has_linux_user(self):
        return self._linux_user is not None

    def _has_linux_password(self):
        return self._linux_password is not None

    def _has_linux_private_key(self):
        return self._arguments.linux_ssh_private_key_file is not None


if __name__ == '__main__':
    post_launch_file_copier = PostLaunchFileCopier()
    post_launch_file_copier.copy()
